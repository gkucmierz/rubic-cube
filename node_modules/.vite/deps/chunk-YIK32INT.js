import {
  indexToPosition,
  isInside,
  positionToUvs
} from "./chunk-ROHLD3FA.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-HPRLEMBT.js";

// node_modules/rubiks-js/src/state/corners.js
var permutations = {
  R: ["DRF", "ULF", "ULB", "URF", "DRB", "DLF", "DLB", "URB"],
  L: ["URF", "ULB", "DLB", "URB", "DRF", "ULF", "DLF", "DRB"],
  U: ["URB", "URF", "ULF", "ULB", "DRF", "DLF", "DLB", "DRB"],
  D: ["URF", "ULF", "ULB", "URB", "DLF", "DLB", "DRB", "DRF"],
  F: ["ULF", "DLF", "ULB", "URB", "URF", "DRF", "DLB", "DRB"],
  B: ["URF", "ULF", "URB", "DRB", "DRF", "DLF", "ULB", "DLB"]
};
var orientations = {
  R: [2, 0, 0, 1, 1, 0, 0, 2],
  L: [0, 1, 2, 0, 0, 2, 1, 0],
  U: [0, 0, 0, 0, 0, 0, 0, 0],
  D: [0, 0, 0, 0, 0, 0, 0, 0],
  F: [1, 2, 0, 0, 2, 1, 0, 0],
  B: [0, 0, 1, 2, 0, 0, 2, 1]
};
var map = {
  URF: {
    URF: {
      0: [],
      1: ["R", "U"],
      2: ["F'", "U'"]
    },
    ULF: {
      0: ["U"],
      1: ["R", "U2"],
      2: ["F'"]
    },
    ULB: {
      0: ["U2"],
      1: ["R", "U'"],
      2: ["F'", "U"]
    },
    URB: {
      0: ["U'"],
      1: ["R"],
      2: ["F'", "U2"]
    },
    DRF: {
      0: ["R2", "D'"],
      1: ["R'"],
      2: ["F"]
    },
    DLF: {
      0: ["F2"],
      1: ["R'", "D'"],
      2: ["F", "D'"]
    },
    DLB: {
      0: ["R2", "D"],
      1: ["R'", "D2"],
      2: ["F", "D2"]
    },
    DRB: {
      0: ["R2"],
      1: ["R'", "D"],
      2: ["F", "D"]
    }
  },
  ULF: {
    URF: {
      0: ["U'"],
      1: ["F"],
      2: ["L'", "U2"]
    },
    ULF: {
      0: [],
      1: ["F", "U"],
      2: ["L'", "U'"]
    },
    ULB: {
      0: ["U"],
      1: ["F", "U2"],
      2: ["L'"]
    },
    URB: {
      0: ["U2"],
      1: ["F", "U'"],
      2: ["L'", "U"]
    },
    DRF: {
      0: ["F2"],
      1: ["F'", "D"],
      2: ["L", "D"]
    },
    DLF: {
      0: ["L2", "D"],
      1: ["F'"],
      2: ["L"]
    },
    DLB: {
      0: ["L2"],
      1: ["F'", "D'"],
      2: ["L", "D'"]
    },
    DRB: {
      0: ["L2", "D'"],
      1: ["F'", "D2"],
      2: ["L", "D2"]
    }
  },
  ULB: {
    URF: {
      0: ["U2"],
      1: ["L", "U'"],
      2: ["B'", "U"]
    },
    ULF: {
      0: ["U'"],
      1: ["L"],
      2: ["B'", "U2"]
    },
    ULB: {
      0: [],
      1: ["L", "U"],
      2: ["B'", "U'"]
    },
    URB: {
      0: ["U"],
      1: ["L", "U2"],
      2: ["B'"]
    },
    DRF: {
      0: ["L2", "D"],
      1: ["L'", "D2"],
      2: ["B", "D2"]
    },
    DLF: {
      0: ["L2"],
      1: ["L'", "D"],
      2: ["B", "D"]
    },
    DLB: {
      0: ["L2", "D"],
      1: ["L'"],
      2: ["B"]
    },
    DRB: {
      0: ["B2"],
      1: ["L'", "D'"],
      2: ["B", "D'"]
    }
  },
  URB: {
    URF: {
      0: ["U"],
      1: ["B", "U2"],
      2: ["R'"]
    },
    ULF: {
      0: ["U2"],
      1: ["B", "U'"],
      2: ["R'", "U"]
    },
    ULB: {
      0: ["U'"],
      1: ["B"],
      2: ["R'", "U2"]
    },
    URB: {
      0: [],
      1: ["B", "U"],
      2: ["R'", "U'"]
    },
    DRF: {
      0: ["R2"],
      1: ["B'", "D'"],
      2: ["R", "D'"]
    },
    DLF: {
      0: ["R2", "D'"],
      1: ["B'", "D2"],
      2: ["R", "D2"]
    },
    DLB: {
      0: ["B2"],
      1: ["B'", "D"],
      2: ["R", "D"]
    },
    DRB: {
      0: ["R2", "D"],
      1: ["B'"],
      2: ["R"]
    }
  },
  DRF: {
    URF: {
      0: ["R2", "U"],
      1: ["F'"],
      2: ["R"]
    },
    ULF: {
      0: ["F2"],
      1: ["F'", "U"],
      2: ["R", "U"]
    },
    ULB: {
      0: ["R2", "U'"],
      1: ["F'", "U2"],
      2: ["R", "U2"]
    },
    URB: {
      0: ["R2"],
      1: ["F'", "U'"],
      2: ["R", "U'"]
    },
    DRF: {
      0: [],
      1: ["F", "D"],
      2: ["R'", "D'"]
    },
    DLF: {
      0: ["D'"],
      1: ["F"],
      2: ["R'", "D2"]
    },
    DLB: {
      0: ["D2"],
      1: ["F", "D'"],
      2: ["R'", "D"]
    },
    DRB: {
      0: ["D"],
      1: ["F", "D2"],
      2: ["R'"]
    }
  },
  DLF: {
    URF: {
      0: ["F2"],
      1: ["L'", "U'"],
      2: ["F", "U'"]
    },
    ULF: {
      0: ["L2", "U'"],
      1: ["L'"],
      2: ["F"]
    },
    ULB: {
      0: ["L2"],
      1: ["L'", "U"],
      2: ["F", "U"]
    },
    URB: {
      0: ["L2", "U"],
      1: ["L'", "U2"],
      2: ["F", "U2"]
    },
    DRF: {
      0: ["D"],
      1: ["L", "D2"],
      2: ["F'"]
    },
    DLF: {
      0: [],
      1: ["L", "D"],
      2: ["F'", "D'"]
    },
    DLB: {
      0: ["D'"],
      1: ["L"],
      2: ["F'", "D2"]
    },
    DRB: {
      0: ["D2"],
      1: ["L", "D'"],
      2: ["F'", "D"]
    }
  },
  DLB: {
    URF: {
      0: ["L2", "U'"],
      1: ["B'", "U2"],
      2: ["L", "U2"]
    },
    ULF: {
      0: ["L2"],
      1: ["B'", "U'"],
      2: ["L", "U'"]
    },
    ULB: {
      0: ["L2", "U"],
      1: ["B'"],
      2: ["L"]
    },
    URB: {
      0: ["B2"],
      1: ["B'", "U"],
      2: ["L", "U"]
    },
    DRF: {
      0: ["D2"],
      1: ["B", "D'"],
      2: ["L'", "D"]
    },
    DLF: {
      0: ["D"],
      1: ["B", "D2"],
      2: ["L'"]
    },
    DLB: {
      0: [],
      1: ["B", "D"],
      2: ["L'", "D'"]
    },
    DRB: {
      0: ["D'"],
      1: ["B"],
      2: ["L'", "D2"]
    }
  },
  DRB: {
    URF: {
      0: ["R2"],
      1: ["R'", "U"],
      2: ["B", "U"]
    },
    ULF: {
      0: ["R2", "U"],
      1: ["R'", "U2"],
      2: ["B", "U2"]
    },
    ULB: {
      0: ["B2"],
      1: ["R'", "U'"],
      2: ["B", "U'"]
    },
    URB: {
      0: ["R2", "U'"],
      1: ["R'"],
      2: ["B"]
    },
    DRF: {
      0: ["D'"],
      1: ["R"],
      2: ["B'", "D2"]
    },
    DLF: {
      0: ["D2"],
      1: ["R", "D'"],
      2: ["B'", "D"]
    },
    DLB: {
      0: ["D"],
      1: ["R", "D2"],
      2: ["B'"]
    },
    DRB: {
      0: [],
      1: ["R", "D"],
      2: ["B'", "D'"]
    }
  }
};
var orderIndexToCubieIndex = [
  6,
  8,
  26,
  24,
  0,
  2,
  20,
  18
];
var _Corners_instances, getTurns_fn;
var _Corners = class _Corners {
  constructor() {
    __privateAdd(this, _Corners_instances);
    /** @type {Permutation} */
    __publicField(this, "permutation", [..._Corners.order]);
    /** @type {Orientation} */
    __publicField(this, "orientation", [0, 0, 0, 0, 0, 0, 0, 0]);
  }
  /** @param {TurnBase} turn */
  applyTurn(turn) {
    const appliedPermutation = permutations[turn];
    const appliedOrientation = orientations[turn];
    const permutation = [...this.permutation];
    const orientation = [...this.orientation];
    for (let i = 0; i < 8; i++) {
      const newPermutation = appliedPermutation[i];
      const orderIndex = _Corners.order.indexOf(newPermutation);
      this.permutation[i] = permutation[orderIndex];
      const newOrientation = (appliedOrientation[i] + orientation[orderIndex]) % 3;
      this.orientation[i] = /** @type {CO} */
      newOrientation;
    }
  }
  /**
   * @param {number[][][]} uvs
   * @param {import('../ui/rubiks').Rubiks} rubiks
   */
  applyState(uvs, rubiks) {
    for (let i = 0; i < 8; i++) {
      const turns = __privateMethod(this, _Corners_instances, getTurns_fn).call(this, i);
      const originIndex = orderIndexToCubieIndex[_Corners.order.indexOf(this.permutation[i])];
      let sideToUvs = createSideToUvs(originIndex, uvs);
      sideToUvs = transformSidetoUvs(originIndex, sideToUvs, turns);
      const targetIndex = orderIndexToCubieIndex[i];
      setUvs(targetIndex, rubiks, sideToUvs);
    }
  }
  reset() {
    this.permutation = [..._Corners.order];
    this.orientation = [0, 0, 0, 0, 0, 0, 0, 0];
  }
  /** @returns {number[]} */
  encode() {
    let p = 0;
    for (const permutation of this.permutation) {
      p = p << 3;
      p += _Corners.order.indexOf(permutation);
    }
    let o = 0;
    for (const orientation of this.orientation) {
      o = o << 2;
      o += orientation;
    }
    return [
      p >> 0 & 255,
      p >> 8 & 255,
      p >> 16 & 255,
      o >> 0 & 255,
      o >> 8 & 255
    ];
  }
  /**
   * @param {number[]} code
   * @returns {boolean}
   */
  decode(code) {
    let p = code[0] + (code[1] << 8) + (code[2] << 16);
    let o = code[3] + (code[4] << 8);
    for (let i = 7; i >= 0; i--) {
      const p1 = p & 7;
      if (p1 >= 8) {
        return false;
      }
      this.permutation[i] = _Corners.order[p1];
      p = p >> 3;
      const o1 = o & 3;
      if (o1 > 2) {
        return false;
      }
      this.orientation[i] = /** @type {CO} */
      o1;
      o = o >> 2;
    }
    return true;
  }
};
_Corners_instances = new WeakSet();
/**
 * @param {number} index
 * @returns {Turn[]}
 */
getTurns_fn = function(index) {
  const start = _Corners.order[index];
  const permutation = this.permutation[index];
  const orientation = this.orientation[index];
  return map[permutation][start][orientation];
};
/** @type {Permutation} */
__publicField(_Corners, "order", ["URF", "ULF", "ULB", "URB", "DRF", "DLF", "DLB", "DRB"]);
var Corners = _Corners;

// node_modules/rubiks-js/src/state/edges.js
var permutations2 = {
  R: ["UF", "UL", "UB", "FR", "DR", "FL", "BL", "UR", "DF", "DL", "DB", "BR"],
  L: ["UF", "BL", "UB", "UR", "FR", "UL", "DL", "BR", "DF", "FL", "DB", "DR"],
  U: ["UR", "UF", "UL", "UB", "FR", "FL", "BL", "BR", "DF", "DL", "DB", "DR"],
  D: ["UF", "UL", "UB", "UR", "FR", "FL", "BL", "BR", "DL", "DB", "DR", "DF"],
  F: ["FL", "UL", "UB", "UR", "UF", "DF", "BL", "BR", "FR", "DL", "DB", "DR"],
  B: ["UF", "UL", "BR", "UR", "FR", "FL", "UB", "DB", "DF", "DL", "BL", "DR"]
};
var orientations2 = {
  R: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  L: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  U: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  D: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  F: [1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0],
  B: [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0]
};
var map2 = {
  UF: {
    UF: {
      0: [],
      1: ["F", "R", "U"]
    },
    UL: {
      0: ["U"],
      1: ["F'", "L'"]
    },
    UB: {
      0: ["U2"],
      1: ["F", "R", "U'"]
    },
    UR: {
      0: ["U'"],
      1: ["F", "R"]
    },
    FR: {
      0: ["U'", "R'"],
      1: ["F"]
    },
    FL: {
      0: ["U", "L"],
      1: ["F'"]
    },
    BL: {
      0: ["U", "L'"],
      1: ["U2", "B"]
    },
    BR: {
      0: ["U'", "R"],
      1: ["U2", "B'"]
    },
    DF: {
      0: ["F2"],
      1: ["F", "R'", "D'"]
    },
    DL: {
      0: ["F2", "D'"],
      1: ["F'", "L"]
    },
    DB: {
      0: ["F2", "D2"],
      1: ["F", "R'", "D"]
    },
    DR: {
      0: ["F2", "D"],
      1: ["F", "R'"]
    }
  },
  UL: {
    UF: {
      0: ["U'"],
      1: ["L", "F"]
    },
    UL: {
      0: [],
      1: ["L", "F", "U"]
    },
    UB: {
      0: ["U"],
      1: ["L'", "B'"]
    },
    UR: {
      0: ["U2"],
      1: ["L", "F", "U'"]
    },
    FR: {
      0: ["U2", "R'"],
      1: ["U'", "F"]
    },
    FL: {
      0: ["L"],
      1: ["U'", "F'"]
    },
    BL: {
      0: ["L'"],
      1: ["U", "B"]
    },
    BR: {
      0: ["U2", "R"],
      1: ["U", "B'"]
    },
    DF: {
      0: ["L2", "D"],
      1: ["L", "F'"]
    },
    DL: {
      0: ["L2"],
      1: ["L", "F'", "D'"]
    },
    DB: {
      0: ["L2", "D'"],
      1: ["L'", "B"]
    },
    DR: {
      0: ["L2", "D2"],
      1: ["L", "F'", "D"]
    }
  },
  UB: {
    UF: {
      0: ["U2"],
      1: ["B'", "R'", "U"]
    },
    UL: {
      0: ["U'"],
      1: ["B", "L"]
    },
    UB: {
      0: [],
      1: ["B'", "R'", "U'"]
    },
    UR: {
      0: ["U"],
      1: ["B'", "R'"]
    },
    FR: {
      0: ["U", "R'"],
      1: ["B'", "R2"]
    },
    FL: {
      0: ["U'", "L"],
      1: ["B", "L2"]
    },
    BL: {
      0: ["U'", "L'"],
      1: ["B"]
    },
    BR: {
      0: ["U", "R"],
      1: ["B'"]
    },
    DF: {
      0: ["B2", "D2"],
      1: ["B'", "R", "D'"]
    },
    DL: {
      0: ["B2", "D"],
      1: ["B", "L'"]
    },
    DB: {
      0: ["B2"],
      1: ["B'", "R", "D"]
    },
    DR: {
      0: ["B2", "D'"],
      1: ["B'", "R"]
    }
  },
  UR: {
    UF: {
      0: ["U"],
      1: ["R'", "F'"]
    },
    UL: {
      0: ["U2"],
      1: ["R'", "F'", "U"]
    },
    UB: {
      0: ["U'"],
      1: ["R", "B"]
    },
    UR: {
      0: [],
      1: ["R'", "F'", "U'"]
    },
    FR: {
      0: ["R'"],
      1: ["U", "F"]
    },
    FL: {
      0: ["U2", "L"],
      1: ["U", "F'"]
    },
    BL: {
      0: ["U2", "L'"],
      1: ["U'", "B"]
    },
    BR: {
      0: ["R"],
      1: ["U'", "B'"]
    },
    DF: {
      0: ["R2", "D'"],
      1: ["R'", "F"]
    },
    DL: {
      0: ["R2", "D2"],
      1: ["R'", "F", "D'"]
    },
    DB: {
      0: ["R2", "D"],
      1: ["R", "B'"]
    },
    DR: {
      0: ["R2"],
      1: ["R'", "F", "D"]
    }
  },
  FR: {
    UF: {
      0: ["R", "U"],
      1: ["F'"]
    },
    UL: {
      0: ["R", "U2"],
      1: ["F'", "U"]
    },
    UB: {
      0: ["R", "U'"],
      1: ["F'", "U2"]
    },
    UR: {
      0: ["R"],
      1: ["F'", "U'"]
    },
    FR: {
      0: [],
      1: ["F'", "U'", "R'"]
    },
    FL: {
      0: ["F2"],
      1: ["F'", "U", "L"]
    },
    BL: {
      0: ["F2", "L2"],
      1: ["F'", "U", "L'"]
    },
    BR: {
      0: ["R2"],
      1: ["F'", "U'", "R"]
    },
    DF: {
      0: ["R'", "D'"],
      1: ["F"]
    },
    DL: {
      0: ["R'", "D2"],
      1: ["F", "D'"]
    },
    DB: {
      0: ["R'", "D"],
      1: ["F", "D2"]
    },
    DR: {
      0: ["R'"],
      1: ["F", "D"]
    }
  },
  FL: {
    UF: {
      0: ["L'", "U'"],
      1: ["F"]
    },
    UL: {
      0: ["L'"],
      1: ["F", "U"]
    },
    UB: {
      0: ["L'", "U"],
      1: ["F", "U2"]
    },
    UR: {
      0: ["L'", "U2"],
      1: ["F", "U'"]
    },
    FR: {
      0: ["F2"],
      1: ["F", "U'", "R'"]
    },
    FL: {
      0: [],
      1: ["F", "U", "L"]
    },
    BL: {
      0: ["L2"],
      1: ["F", "U", "L'"]
    },
    BR: {
      0: ["F2", "R2"],
      1: ["F", "U'", "R"]
    },
    DF: {
      0: ["L", "D"],
      1: ["F'"]
    },
    DL: {
      0: ["L"],
      1: ["F'", "D'"]
    },
    DB: {
      0: ["L", "D'"],
      1: ["F'", "D2"]
    },
    DR: {
      0: ["L", "D2"],
      1: ["F'", "D"]
    }
  },
  BL: {
    UF: {
      0: ["L", "U'"],
      1: ["B'", "U2"]
    },
    UL: {
      0: ["L"],
      1: ["B'", "U'"]
    },
    UB: {
      0: ["L", "U"],
      1: ["B'"]
    },
    UR: {
      0: ["L", "U2"],
      1: ["B'", "U"]
    },
    FR: {
      0: ["B2", "R2"],
      1: ["B'", "U", "R'"]
    },
    FL: {
      0: ["L2"],
      1: ["B'", "U'", "L"]
    },
    BL: {
      0: [],
      1: ["B'", "U'", "L'"]
    },
    BR: {
      0: ["B2"],
      1: ["B'", "U", "R"]
    },
    DF: {
      0: ["L'", "D"],
      1: ["B", "D2"]
    },
    DL: {
      0: ["L'"],
      1: ["B", "D"]
    },
    DB: {
      0: ["L'", "D'"],
      1: ["B"]
    },
    DR: {
      0: ["L'", "D2"],
      1: ["B", "D'"]
    }
  },
  BR: {
    UF: {
      0: ["R'", "U"],
      1: ["B", "U2"]
    },
    UL: {
      0: ["R'", "U2"],
      1: ["B", "U'"]
    },
    UB: {
      0: ["R'", "U'"],
      1: ["B"]
    },
    UR: {
      0: ["R'"],
      1: ["B", "U"]
    },
    FR: {
      0: ["R2"],
      1: ["B", "U", "R'"]
    },
    FL: {
      0: ["B2", "L2"],
      1: ["B", "U'", "L"]
    },
    BL: {
      0: ["B2"],
      1: ["B", "U'", "L'"]
    },
    BR: {
      0: [],
      1: ["B", "U", "R"]
    },
    DF: {
      0: ["R", "D'"],
      1: ["B'", "D2"]
    },
    DL: {
      0: ["R", "D2"],
      1: ["B'", "D"]
    },
    DB: {
      0: ["R", "D"],
      1: ["B'"]
    },
    DR: {
      0: ["R"],
      1: ["B'", "D'"]
    }
  },
  DF: {
    UF: {
      0: ["F2"],
      1: ["F'", "R", "U"]
    },
    UL: {
      0: ["F2", "U"],
      1: ["F", "L'"]
    },
    UB: {
      0: ["F2", "U2"],
      1: ["F'", "R", "U'"]
    },
    UR: {
      0: ["F2", "U'"],
      1: ["F'", "R"]
    },
    FR: {
      0: ["D", "R"],
      1: ["F'"]
    },
    FL: {
      0: ["D'", "L'"],
      1: ["F"]
    },
    BL: {
      0: ["D'", "L"],
      1: ["D2", "B'"]
    },
    BR: {
      0: ["D", "R'"],
      1: ["D2", "B"]
    },
    DF: {
      0: [],
      1: ["F'", "R'", "D'"]
    },
    DL: {
      0: ["D'"],
      1: ["F", "L"]
    },
    DB: {
      0: ["D2"],
      1: ["F'", "R'", "D"]
    },
    DR: {
      0: ["D"],
      1: ["F'", "R'"]
    }
  },
  DL: {
    UF: {
      0: ["L2", "U'"],
      1: ["L'", "F"]
    },
    UL: {
      0: ["L2"],
      1: ["L'", "F", "U"]
    },
    UB: {
      0: ["L2", "U"],
      1: ["L", "B'"]
    },
    UR: {
      0: ["L2", "U2"],
      1: ["L'", "F", "U'"]
    },
    FR: {
      0: ["D2", "R"],
      1: ["D", "F'"]
    },
    FL: {
      0: ["L'"],
      1: ["D", "F"]
    },
    BL: {
      0: ["L"],
      1: ["D'", "B'"]
    },
    BR: {
      0: ["D2", "R'"],
      1: ["D'", "B"]
    },
    DF: {
      0: ["D"],
      1: ["L'", "F'"]
    },
    DL: {
      0: [],
      1: ["L'", "F'", "D'"]
    },
    DB: {
      0: ["D'"],
      1: ["L", "B"]
    },
    DR: {
      0: ["D2"],
      1: ["L'", "F'", "D"]
    }
  },
  DB: {
    UF: {
      0: ["B2", "U2"],
      1: ["B", "R'", "U"]
    },
    UL: {
      0: ["B2", "U'"],
      1: ["B'", "L"]
    },
    UB: {
      0: ["B2"],
      1: ["B", "R'", "U'"]
    },
    UR: {
      0: ["B2", "U"],
      1: ["B", "R'"]
    },
    FR: {
      0: ["D'", "R"],
      1: ["D2", "F'"]
    },
    FL: {
      0: ["D", "L'"],
      1: ["D2", "F"]
    },
    BL: {
      0: ["D", "L"],
      1: ["B'"]
    },
    BR: {
      0: ["D'", "R'"],
      1: ["B"]
    },
    DF: {
      0: ["D2"],
      1: ["B", "R", "D'"]
    },
    DL: {
      0: ["D"],
      1: ["B'", "L'"]
    },
    DB: {
      0: [],
      1: ["B", "R", "D"]
    },
    DR: {
      0: ["D'"],
      1: ["B", "R"]
    }
  },
  DR: {
    UF: {
      0: ["R2", "U"],
      1: ["R", "F'"]
    },
    UL: {
      0: ["R2", "U2"],
      1: ["R", "F'", "U"]
    },
    UB: {
      0: ["R2", "U'"],
      1: ["R'", "B"]
    },
    UR: {
      0: ["R2"],
      1: ["R", "F'", "U'"]
    },
    FR: {
      0: ["R"],
      1: ["D'", "F'"]
    },
    FL: {
      0: ["D2", "L'"],
      1: ["D'", "F"]
    },
    BL: {
      0: ["D2", "L"],
      1: ["D", "B'"]
    },
    BR: {
      0: ["R'"],
      1: ["D", "B"]
    },
    DF: {
      0: ["D'"],
      1: ["R", "F"]
    },
    DL: {
      0: ["D2"],
      1: ["R", "F", "D'"]
    },
    DB: {
      0: ["D"],
      1: ["R'", "B'"]
    },
    DR: {
      0: [],
      1: ["R", "F", "D"]
    }
  }
};
var orderIndexToCubieIndex2 = [
  7,
  17,
  25,
  15,
  3,
  5,
  23,
  21,
  1,
  11,
  19,
  9
];
var _Edges_instances, getTurns_fn2;
var _Edges = class _Edges {
  constructor() {
    __privateAdd(this, _Edges_instances);
    /** @type {Permutation} */
    __publicField(this, "permutation", [..._Edges.order]);
    /** @type {Orientation} */
    __publicField(this, "orientation", [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  }
  /** @param {TurnBase} turn */
  applyTurn(turn) {
    const appliedPermutation = permutations2[turn];
    const appliedOrientation = orientations2[turn];
    const permutation = [...this.permutation];
    const orientation = [...this.orientation];
    for (let i = 0; i < 12; i++) {
      const newPermutation = appliedPermutation[i];
      const orderIndex = _Edges.order.indexOf(newPermutation);
      this.permutation[i] = permutation[orderIndex];
      const newOrientation = (appliedOrientation[i] + orientation[orderIndex]) % 2;
      this.orientation[i] = /** @type {EO} */
      newOrientation;
    }
  }
  /**
   * @param {number[][][]} uvs
   * @param {import('../ui/rubiks').Rubiks} rubiks
   */
  applyState(uvs, rubiks) {
    for (let i = 0; i < 12; i++) {
      const turns = __privateMethod(this, _Edges_instances, getTurns_fn2).call(this, i);
      const originIndex = orderIndexToCubieIndex2[_Edges.order.indexOf(this.permutation[i])];
      let sideToUvs = createSideToUvs(originIndex, uvs);
      sideToUvs = transformSidetoUvs(originIndex, sideToUvs, turns);
      const targetIndex = orderIndexToCubieIndex2[i];
      setUvs(targetIndex, rubiks, sideToUvs);
    }
  }
  reset() {
    this.permutation = [..._Edges.order];
    this.orientation = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  /** @returns {number[]} */
  encode() {
    let p = [];
    for (let i = 0; i < 6; i++) {
      const p1 = _Edges.order.indexOf(this.permutation[i * 2]);
      const p2 = _Edges.order.indexOf(this.permutation[i * 2 + 1]);
      p.push(
        (p2 << 4) + p1
      );
    }
    let o = 0;
    for (const orientation of this.orientation) {
      o = o << 1;
      o += orientation;
    }
    return [
      ...p,
      o >> 0 & 255,
      o >> 8 & 255
    ];
  }
  /**
   * @param {number[]} code
   * @returns {boolean}
   */
  decode(code) {
    for (let i = 0; i < 6; i++) {
      const p1 = code[i] & 15;
      const p2 = code[i] >> 4 & 15;
      if (p1 >= 12 || p2 >= 12) {
        return false;
      }
      this.permutation[i * 2] = _Edges.order[p1];
      this.permutation[i * 2 + 1] = _Edges.order[p2];
    }
    let o = code[6] + (code[7] << 8);
    for (let i = 11; i >= 0; i--) {
      this.orientation[i] = /** @type {EO} */
      o & 1;
      o = o >> 1;
    }
    return true;
  }
};
_Edges_instances = new WeakSet();
/**
 * @param {number} index
 * @returns {Turn[]}
 */
getTurns_fn2 = function(index) {
  const start = _Edges.order[index];
  const permutation = this.permutation[index];
  const orientation = this.orientation[index];
  return map2[permutation][start][orientation];
};
/** @type {Permutation} */
__publicField(_Edges, "order", ["UF", "UL", "UB", "UR", "FR", "FL", "BL", "BR", "DF", "DL", "DB", "DR"]);
var Edges = _Edges;

// node_modules/rubiks-js/src/math/utils.js
var mod = (a, b) => {
  return (a % b + b) % b;
};
var lerp = (a, b, t) => {
  return a + (b - a) * t;
};
var clamp = (x, min, max) => {
  return Math.min(Math.max(x, min), max);
};

// node_modules/rubiks-js/src/state/centers.js
var orderIndexToCubieIndex3 = [
  12,
  14,
  10,
  16,
  4,
  22
];
var _Centers = class _Centers {
  constructor() {
    /** @type {Orientation} */
    __publicField(this, "orientation", [0, 0, 0, 0, 0, 0]);
  }
  /** @param {TurnBase} turn */
  applyTurn(turn) {
    const index = _Centers.order.indexOf(turn);
    this.orientation[index] = /** @type {CO} */
    mod(this.orientation[index] + 1, 4);
  }
  /**
   * @param {number[][][]} uvs
   * @param {import('../ui/rubiks').Rubiks} rubiks
   */
  applyState(uvs, rubiks) {
    for (let side = 0; side < 6; side++) {
      const uv = uvs[side][4];
      const offset = this.orientation[side] * 2;
      const cubieIndex = orderIndexToCubieIndex3[side];
      const facelet = rubiks.cubies[cubieIndex].getFaceletOfSide(side);
      facelet.uvs = [];
      for (let i = 0; i < 8; i++) {
        facelet.uvs[i] = uv[mod(offset + i, 8)];
      }
    }
  }
  reset() {
    this.orientation = [0, 0, 0, 0, 0, 0];
  }
  /** @returns {number[]} */
  encode() {
    let o = 0;
    for (const orientation of this.orientation) {
      o = o << 2;
      o += orientation;
    }
    return [
      o >> 0 & 255,
      o >> 8 & 255
    ];
  }
  /** @param {number[]} code */
  decode(code) {
    let o = code[0] + (code[1] << 8);
    for (let i = 5; i >= 0; i--) {
      this.orientation[i] = /** @type {CO} */
      o & 3;
      o = o >> 2;
    }
  }
};
/** @type {Permutation} */
__publicField(_Centers, "order", ["R", "L", "D", "U", "F", "B"]);
var Centers = _Centers;

// node_modules/rubiks-js/src/converter.js
var axisToTurn = [
  ["R", "L", false],
  ["D", "U", true],
  ["F", "B", false]
];
var convertAiaToTurn = (aia) => {
  if (aia.index === 1) {
    throw new Error("Cannot convert middle turns");
  }
  let [a, b, invert] = axisToTurn[aia.axis];
  const turn = aia.index === 0 ? a : b;
  if (aia.angle === 2) {
    return `${turn}2`;
  }
  if (aia.index === 2) {
    invert = !invert;
  }
  if (aia.angle === 3 && !invert || aia.angle === 1 && invert) {
    return `${turn}'`;
  }
  return turn;
};
var turnToAia = {
  R: [0, 0, false],
  L: [0, 2, false],
  D: [1, 0, true],
  U: [1, 2, true],
  F: [2, 0, false],
  B: [2, 2, false]
};
var convertTurnToAia = (turn) => {
  const base = (
    /** @type {TurnBase} */
    turn[0]
  );
  const [axis, index, invert] = turnToAia[base];
  if (turn.endsWith("2")) {
    return { axis, index, angle: 2 };
  }
  let prime = turn.endsWith("'");
  if (invert) {
    prime = !prime;
  }
  let angle = 3;
  if (index === 0 && !prime || index === 2 && prime) {
    angle = 1;
  }
  return { axis, index, angle };
};
var convertTurnToTurnBase = (turn) => {
  const base = (
    /** @type {TurnBase} */
    turn[0]
  );
  if (turn.endsWith("2")) {
    return [base, base];
  }
  if (turn.endsWith("'")) {
    return [base, base, base];
  }
  return [base];
};

// node_modules/rubiks-js/src/ui/uvs.js
var uvsTransformers = {
  identity: (uvs) => [...uvs],
  flipH: (uvs) => [uvs[6], uvs[7], uvs[4], uvs[5], uvs[2], uvs[3], uvs[0], uvs[1]],
  flipV: (uvs) => [uvs[2], uvs[3], uvs[0], uvs[1], uvs[6], uvs[7], uvs[4], uvs[5]],
  rotateCC: (uvs) => [uvs[6], uvs[7], uvs[0], uvs[1], uvs[2], uvs[3], uvs[4], uvs[5]],
  rotateC: (uvs) => [uvs[2], uvs[3], uvs[4], uvs[5], uvs[6], uvs[7], uvs[0], uvs[1]],
  rotate2: (uvs) => [uvs[4], uvs[5], uvs[6], uvs[7], uvs[0], uvs[1], uvs[2], uvs[3]],
  rotateCFlipH: (uvs) => [uvs[0], uvs[1], uvs[6], uvs[7], uvs[4], uvs[5], uvs[2], uvs[3]]
};
var uvsTransformerPresets = {
  flipV12: {
    1: uvsTransformers.flipV,
    2: uvsTransformers.flipV,
    3: uvsTransformers.identity
  },
  flipV23: {
    1: uvsTransformers.identity,
    2: uvsTransformers.flipV,
    3: uvsTransformers.flipV
  },
  flipH12: {
    1: uvsTransformers.flipH,
    2: uvsTransformers.flipH,
    3: uvsTransformers.identity
  },
  flipH23: {
    1: uvsTransformers.identity,
    2: uvsTransformers.flipH,
    3: uvsTransformers.flipH
  },
  rcfhFvRcc: {
    1: uvsTransformers.rotateCFlipH,
    2: uvsTransformers.flipV,
    3: uvsTransformers.rotateCC
  },
  rcFvRcfh: {
    1: uvsTransformers.rotateC,
    2: uvsTransformers.flipV,
    3: uvsTransformers.rotateCFlipH
  },
  rcFhRcfh: {
    1: uvsTransformers.rotateC,
    2: uvsTransformers.flipH,
    3: uvsTransformers.rotateCFlipH
  },
  rcfhFhRcc: {
    1: uvsTransformers.rotateCFlipH,
    2: uvsTransformers.flipH,
    3: uvsTransformers.rotateCC
  },
  rcR2Rcc: {
    1: uvsTransformers.rotateC,
    2: uvsTransformers.rotate2,
    3: uvsTransformers.rotateCC
  },
  rccR2Rc: {
    1: uvsTransformers.rotateCC,
    2: uvsTransformers.rotate2,
    3: uvsTransformers.rotateC
  }
};
var cubiesShiftMapper = {
  0: {
    0: [0, 3, 6, 15, 24, 21, 18, 9],
    2: [2, 5, 8, 17, 26, 23, 20, 11]
  },
  1: {
    0: [0, 1, 2, 11, 20, 19, 18, 9],
    2: [6, 7, 8, 17, 26, 25, 24, 15]
  },
  2: {
    0: [0, 1, 2, 5, 8, 7, 6, 3],
    2: [18, 19, 20, 23, 26, 25, 24, 21]
  }
};
var sidesShiftMapper = [
  [2, 5, 3, 4],
  [0, 5, 1, 4],
  [0, 3, 1, 2]
];

// node_modules/rubiks-js/src/state/index.js
var _corners, _edges, _centers, _trackCenters;
var State = class {
  /** @param {boolean} trackCenters */
  constructor(trackCenters) {
    __privateAdd(this, _corners, new Corners());
    __privateAdd(this, _edges, new Edges());
    __privateAdd(this, _centers, new Centers());
    /** @type {boolean} */
    __privateAdd(this, _trackCenters);
    __publicField(this, "stateInfo", new StateInfo(this));
    __privateSet(this, _trackCenters, trackCenters);
  }
  /** @param {Turn} turn */
  applyTurn(turn) {
    const baseTurns = convertTurnToTurnBase(turn);
    for (const base of baseTurns) {
      __privateGet(this, _corners).applyTurn(base);
      __privateGet(this, _edges).applyTurn(base);
      if (__privateGet(this, _trackCenters)) {
        __privateGet(this, _centers).applyTurn(base);
      }
    }
  }
  /**
   * @param {number[][][]} uvs
   * @param {import('../ui/rubiks').Rubiks} rubiks
   */
  applyState(uvs, rubiks) {
    __privateGet(this, _corners).applyState(uvs, rubiks);
    __privateGet(this, _edges).applyState(uvs, rubiks);
    if (__privateGet(this, _trackCenters)) {
      __privateGet(this, _centers).applyState(uvs, rubiks);
    }
  }
  /** @returns {string} */
  encode() {
    const code = [];
    code.push(...__privateGet(this, _corners).encode());
    code.push(...__privateGet(this, _edges).encode());
    if (__privateGet(this, _trackCenters)) {
      code.push(...__privateGet(this, _centers).encode());
    }
    const array = new Uint8Array(code);
    return btoa(String.fromCharCode(...array));
  }
  /**
   * @param {string} str
   * @returns {boolean}
   */
  decode(str) {
    const data = atob(str);
    if (data.length !== (__privateGet(this, _trackCenters) ? 15 : 13)) {
      return false;
    }
    const code = [];
    for (let i = 0; i < data.length; i++) {
      code.push(data.charCodeAt(i));
    }
    const corners = __privateGet(this, _corners);
    const cp = [...corners.permutation];
    const co = [...corners.orientation];
    if (!corners.decode(code.slice(0, 5))) {
      corners.permutation = cp;
      corners.orientation = co;
      return false;
    }
    const edges = __privateGet(this, _edges);
    const ep = [...edges.permutation];
    const eo = [...edges.orientation];
    if (!edges.decode(code.slice(5, 13))) {
      corners.permutation = cp;
      corners.orientation = co;
      edges.permutation = ep;
      edges.orientation = eo;
      return false;
    }
    if (__privateGet(this, _trackCenters)) {
      __privateGet(this, _centers).decode(code.slice(13));
    }
    return true;
  }
  reset() {
    __privateGet(this, _corners).reset();
    __privateGet(this, _edges).reset();
    __privateGet(this, _centers).reset();
  }
};
_corners = new WeakMap();
_edges = new WeakMap();
_centers = new WeakMap();
_trackCenters = new WeakMap();
var _state;
var StateInfo = class {
  /** @param {State} state */
  constructor(state) {
    /** @type {State} */
    __privateAdd(this, _state);
    __privateSet(this, _state, state);
  }
  /**
   * @returns {string} base64 encoded, can be used in the setState method
   */
  toString() {
    return __privateGet(this, _state).encode();
  }
};
_state = new WeakMap();
var uvsTransformers2 = {
  0: {
    0: uvsTransformerPresets.rcR2Rcc,
    1: uvsTransformerPresets.rcR2Rcc,
    2: uvsTransformerPresets.flipV12,
    3: uvsTransformerPresets.flipV12,
    4: uvsTransformerPresets.flipV23,
    5: uvsTransformerPresets.flipV23
  },
  1: {
    0: uvsTransformerPresets.rcFvRcfh,
    1: uvsTransformerPresets.rcFvRcfh,
    2: uvsTransformerPresets.rcR2Rcc,
    3: uvsTransformerPresets.rcR2Rcc,
    4: uvsTransformerPresets.rcfhFhRcc,
    5: uvsTransformerPresets.rcfhFhRcc
  },
  2: {
    0: uvsTransformerPresets.flipH12,
    1: uvsTransformerPresets.flipH12,
    2: uvsTransformerPresets.flipH23,
    3: uvsTransformerPresets.flipH23,
    4: uvsTransformerPresets.rcR2Rcc,
    5: uvsTransformerPresets.rcR2Rcc
  }
};
var createSideToUvs = (originIndex, uvs) => {
  const pos = indexToPosition(originIndex);
  const sideToUvs = {};
  for (let side = 0; side < 6; side++) {
    const inside = isInside(side, originIndex);
    if (inside) {
      continue;
    }
    sideToUvs[side] = positionToUvs(pos, side, uvs);
  }
  return sideToUvs;
};
var transformSidetoUvs = (originIndex, sideToUvs, turns) => {
  for (const turn of turns) {
    let { axis, index, angle } = convertTurnToAia(turn);
    const innerSide = axis * 2 + Math.sign(index);
    const newSideToUvs = {};
    for (const [sideStr, uvs] of Object.entries(sideToUvs)) {
      const side = parseInt(sideStr);
      const transformer = uvsTransformers2[axis][side][angle];
      if (side === innerSide) {
        newSideToUvs[innerSide] = transformer(uvs);
        continue;
      }
      const sideIndex = sidesShiftMapper[axis].indexOf(side);
      const newSide = sidesShiftMapper[axis][mod(sideIndex - angle, 4)];
      newSideToUvs[newSide] = transformer(uvs);
    }
    const mapperIndex = cubiesShiftMapper[axis][index].indexOf(originIndex);
    originIndex = cubiesShiftMapper[axis][index][mod(mapperIndex + angle * 2, 8)];
    sideToUvs = newSideToUvs;
  }
  return sideToUvs;
};
var setUvs = (targetIndex, rubiks, sideToUvs) => {
  const cubie = rubiks.cubies[targetIndex];
  for (const facelet of cubie.facelets) {
    facelet.uvs = sideToUvs[facelet.side];
  }
};

export {
  mod,
  lerp,
  clamp,
  convertAiaToTurn,
  uvsTransformerPresets,
  sidesShiftMapper,
  State,
  StateInfo,
  createSideToUvs,
  transformSidetoUvs,
  setUvs
};
//# sourceMappingURL=chunk-YIK32INT.js.map
