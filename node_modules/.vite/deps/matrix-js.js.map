{
  "version": 3,
  "sources": ["../../matrix-js/lib/rational.js", "../../matrix-js/lib/merge.js", "../../matrix-js/lib/generate.js", "../../matrix-js/lib/index.js"],
  "sourcesContent": ["'use strict';\r\n\r\n/**\r\n * Constructs an object storing rational numbers and methods performing operations\r\n * \r\n * @param num numerator of the rational number\r\n * @param den denomenator of the rational number\r\n * @returns Object storing the rational number and method doing arthmetic operations\r\n */\r\nfunction rational(num, den) {\r\n  den = den || 1;\r\n  if (Math.sign(den) === -1) {\r\n    num = -num;\r\n    den = -den;\r\n  }\r\n  return {\r\n    num: num,\r\n    den: den,\r\n    add: (op) => rational(num * op.den + den * op.num, den * op.den),\r\n    sub: (op) => rational(num * op.den - den * op.num, den * op.den),\r\n    mul: (op) => multiply(op, num, den),\r\n    div: (op) => {\r\n      let _num = op.den;\r\n      let _den = op.num;\r\n      return multiply(rational(_num, _den), num, den);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = rational;\r\n\r\n/**\r\n * Multiplies two rational number based on multiplication rules that cancels common terms\r\n * \r\n * @param op the second operand\r\n * @param num numerator of first operand\r\n * @param den denominator of second operand\r\n * @returns another rational number\r\n */\r\nfunction multiply(op, num, den) {\r\n  let _num = Math.sign(num) * Math.sign(op.num);\r\n  let _den = Math.sign(den) * Math.sign(op.den);\r\n  if (Math.abs(num) === Math.abs(op.den) && Math.abs(den) === Math.abs(op.num)) {\r\n    _num = _num;\r\n    _den = _den;\r\n  } else if (Math.abs(den) === Math.abs(op.num)) {\r\n    _num = _num * Math.abs(num);\r\n    _den = _den * Math.abs(op.den);\r\n  } else if (Math.abs(num) === Math.abs(op.den)) {\r\n    _num = _num * Math.abs(op.num);\r\n    _den = _den * Math.abs(den);\r\n  } else {\r\n    _num = num * op.num;\r\n    _den = den * op.den;\r\n  }\r\n  return rational(_num, _den);\r\n}\r\n", "'use strict';\r\n\r\n/**\r\n * Merges two matrices in all directions\r\n * \r\n * @param {Array} base Base matrix on which merge is performed\r\n */\r\nfunction merge(base) {\r\n    return {\r\n        top: (mergeData) => top(base, mergeData),\r\n        bottom: (mergeData) => bottom(base, mergeData),\r\n        left: (mergeData) => left(base, mergeData),\r\n        right: (mergeData) => right(base, mergeData)\r\n    }\r\n}\r\n\r\nmodule.exports = merge;\r\n\r\n/**\r\n * Merges the base matrix with the incoming matrix in the top direction\r\n * @param {Array} base \r\n * @param {Array} mergeData incoming matrix\r\n */\r\nfunction top(base, mergeData) {\r\n    let baseWidth = base[0].length || base.length;\r\n    let mergeDataWidth = mergeData[mergeData.length - 1].length || mergeData.length;\r\n\r\n    if (baseWidth !== mergeDataWidth) {\r\n        return base;\r\n    }\r\n\r\n    if (!Array.isArray(base[0])) {\r\n        base = [base];\r\n    }\r\n\r\n    if (!Array.isArray(mergeData[mergeData.length - 1])) {\r\n        mergeData = [mergeData];\r\n    }\r\n\r\n    for (let row = mergeData.length - 1; row >= 0; row--) {\r\n        base.unshift(mergeData[row].map((ele) => ele));\r\n    }\r\n    return base;\r\n}\r\n\r\n/**\r\n * Merges the base matrix with the incoming matrix in the bottom direction\r\n * @param {Array} base \r\n * @param {Array} mergeData incoming matrix\r\n */\r\nfunction bottom(base, mergeData) {\r\n    let baseWidth = base[base.length - 1].length || base.length;\r\n    let mergeDataWidth = mergeData[0].length || mergeData.length;\r\n    if (baseWidth !== mergeDataWidth) {\r\n        return base;\r\n    }\r\n\r\n    if (!Array.isArray(base[base.length - 1])) {\r\n        base = [base];\r\n    }\r\n\r\n    if (!Array.isArray(mergeData[0])) {\r\n        mergeData = [mergeData];\r\n    }\r\n\r\n\r\n    for (let row = 0; row < mergeData.length; row++) {\r\n        base.push(mergeData[row].map((ele) => ele));\r\n    }\r\n    return base;\r\n}\r\n\r\n/**\r\n * Merges the base matrix with the incoming matrix in the left direction\r\n * @param {Array} base \r\n * @param {Array} mergeData incoming matrix\r\n */\r\nfunction left(base, mergeData) {\r\n    let baseHeight = base.length;\r\n    let mergeDataHeight = mergeData.length;\r\n    if (!Array.isArray(base[0]) && !Array.isArray(mergeData[0])) {\r\n        base.unshift.apply(base, mergeData);\r\n        return base;\r\n    }\r\n\r\n    if (baseHeight !== mergeDataHeight) {\r\n        return base;\r\n    }\r\n\r\n    for (let row = 0; row < baseHeight; row++) {\r\n        base[row].unshift.apply(base[row], mergeData[row].map((ele) => ele));\r\n    }\r\n    return base;\r\n}\r\n\r\n/**\r\n * Merges the base matrix with the incoming matrix in the right direction\r\n * @param {Array} base \r\n * @param {Array} mergeData incoming matrix\r\n */\r\nfunction right(base, mergeData) {\r\n    let baseHeight = base.length;\r\n    let mergeDataHeight = mergeData.length;\r\n    if (!Array.isArray(base[0]) && !Array.isArray(mergeData[0])) {\r\n        base.push.apply(base, mergeData);\r\n        return base;\r\n    }\r\n\r\n    if (baseHeight !== mergeDataHeight) {\r\n        return base;\r\n    }\r\n\r\n    for (let row = 0; row < baseHeight; row++) {\r\n        base[row].push.apply(base[row], mergeData[row].map((ele) => ele));\r\n    }\r\n    return base;\r\n}\r\n", "'use strict';\r\n\r\nfunction generate(val) {\r\n    return {\r\n        size: (row, col) => size(val, row, col),\r\n        diag: (row, col) => diag(val, row, col)\r\n    }\r\n}\r\n\r\nfunction size(val, row, col) {\r\n    if (!col) {\r\n        col = row;\r\n    }\r\n    let rows = [];\r\n    for (let i = 0; i < row; i++) {\r\n        let cols = [];\r\n        for (let j = 0; j < col; j++) {\r\n            cols[j] = val || Math.random(); \r\n        }\r\n        rows[i] = cols;\r\n    }\r\n    return rows;\r\n}\r\n\r\nfunction diag(val, row, col) {\r\n    if (!col) {\r\n        col = row;\r\n    }\r\n    let rows = [];\r\n    for (let i = 0; i < row; i++) {\r\n        let cols = [];\r\n        for (let j = 0; j < col; j++) {\r\n            cols[j] = 0; \r\n        }\r\n        rows[i] = cols;\r\n        if (i < col || row == col) {\r\n            rows[i][i] = val || Math.random();\r\n        }\r\n    }\r\n    return rows;\r\n}\r\n\r\nmodule.exports = generate;\r\n", "'use strict';\r\n\r\nconst rational = require('./rational');\r\nconst merge = require('./merge');\r\nconst generate = require('./generate');\r\n\r\n/**\r\n * Pass a 2-dimensional array that will return a function accepting indices to access the matrix\r\n *\r\n * @param mat array that initializes the matrix\r\n * @returns function with the array initialized and access to method that perform operations on the matrix\r\n */\r\nfunction matrix(mat) {\r\n    if (!Array.isArray(mat)) {\r\n        throw new Error('Input should be of type array');\r\n    }\r\n    let _matrix = function() {\r\n        let args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));\r\n        return read(mat, args);\r\n    }\r\n    return Object.assign(_matrix, _mat(mat));\r\n}\r\n\r\nmatrix.gen = generate;\r\n\r\n/**\r\n * Private function that returns an object containing methods\r\n * that perform operations on the matrix\r\n *\r\n * @param mat array that initializes the matrix\r\n * @returns object of methods performing matrix operations\r\n */\r\nfunction _mat(mat) {\r\n    return {\r\n        size: () => size(mat),\r\n        add: (operand) => operate(mat, operand, addition),\r\n        sub: (operand) => operate(mat, operand, subtraction),\r\n        mul: (operand) => operate(mat, operand, multiplication),\r\n        div: (operand) => operate(mat, operand, division),\r\n        prod: (operand) => prod(mat, operand),\r\n        trans: () => trans(mat),\r\n        set: function() {\r\n            let args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));\r\n            return {\r\n                to: (val) => replace(mat, val, args)\r\n            }\r\n        },\r\n        det: () => determinant(mat),\r\n        inv: () => invert(mat),\r\n        merge: merge(mat),\r\n        map: (func) => map(mat, func),\r\n        equals: (operand) => equals(mat, operand),\r\n    };\r\n}\r\n\r\nmodule.exports = matrix;\r\n\r\n\r\n/**\r\n * Calculates the size of the array across each dimension\r\n *\r\n * @param mat input matrix that initialized the function\r\n * @returns size of the matrix as an array\r\n */\r\nfunction size(mat) {\r\n    let s = [];\r\n    while (Array.isArray(mat)) {\r\n        s.push(mat.length);\r\n        mat = mat[0];\r\n    }\r\n    return s;\r\n}\r\n\r\n\r\n/**\r\n * Private function to calculate the dimensions of the matrix\r\n *\r\n * @param mat input matrix that initializes the function\r\n * @returns integer indicating the number of dimensions\r\n */\r\nfunction dimensions(mat) {\r\n    return size(mat).length;\r\n}\r\n\r\n\r\n/**\r\n * Outputs the original matrix or a particular element or a matrix that is part of the original\r\n *\r\n * @param mat input matrix that initializes the function\r\n * @param args indices to access one or more array elements\r\n * @returns array or single element\r\n */\r\nfunction read(mat, args) {\r\n    if (args.length === 0) {\r\n        return mat;\r\n    } else {\r\n        return extract(mat, args);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Private function to extract a single element or a matrix that is part of the original\r\n *\r\n * @param mat input matrix that initializes the function\r\n * @param args indices to access one or more array elements\r\n * @returns array or single element\r\n */\r\nfunction extract(mat, args) {\r\n    let dim = dimensions(mat);\r\n    for (let i = 0; i < dim; i++) {\r\n        let d = args[i];\r\n        if (d === undefined) {\r\n            break;\r\n        }\r\n        if (Array.isArray(d)) {\r\n            // if an element of args is an array, more extraction is needed\r\n            mat = extractRange(mat, d, i);\r\n        } else if (Number.isInteger(d)) {\r\n            if (dimensions(mat) > 1 && i > 0) {\r\n                mat = mat.map(function(elem) {\r\n                    return [elem[d]];\r\n                });\r\n            } else {\r\n                mat = mat[d];\r\n            }\r\n        }\r\n    }\r\n    return mat;\r\n}\r\n\r\n\r\n/**\r\n * Private function to extract a portion of the array based on the specified range\r\n *\r\n * @param mat input matrix that initialized the function\r\n * @param arg single argument containing the range specified as an array\r\n * @param ind the current index of the arguments while extracting the matrix\r\n * @returns array from the specified range\r\n */\r\nfunction extractRange(mat, arg, ind) {\r\n    if (!arg.length) {\r\n        return mat;\r\n    } else if (arg.length === 2) {\r\n        let reverse = arg[0] > arg[1];\r\n        let first = (!reverse) ? arg[0] : arg[1];\r\n        let last = (!reverse) ? arg[1]: arg[0];\r\n        if (dimensions(mat) > 1 && ind > 0) {\r\n            return mat.map(function(elem) {\r\n                if (reverse) {\r\n                    return elem.slice(first, last+1).reverse();\r\n                }\r\n                return elem.slice(first, last+1);\r\n            })\r\n        } else {\r\n            mat = mat.slice(first, last+1);\r\n            return (reverse && mat.reverse()) || mat;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Replaces the specified index in the matrix with the specified value\r\n *\r\n * @param mat input matrix that initialized the function\r\n * @param value specified value that replace current value at index or indices\r\n * @param args index or indices passed in arguments to initialized function\r\n * @returns replaced matrix\r\n */\r\nfunction replace(mat, value, args) { //TODO: Clean this function up\r\n    let result = clone(mat);\r\n    let prev = args[0];\r\n    let start = prev[0] || 0;\r\n    let end = prev[1] && prev[1] + 1 || mat.length;\r\n    if (!Array.isArray(prev) && args.length === 1) {\r\n        result[prev].fill(value);\r\n    } else if (args.length === 1) {\r\n        for (let ind = start; ind < end; ind++) {\r\n            result[ind].fill(value);\r\n        }\r\n    }\r\n    for (let i = 1; i < args.length; i++) {\r\n        let first = Array.isArray(args[i]) ? args[i][0] || 0 : args[i];\r\n        let last = Array.isArray(args[i]) ? args[i][1] && args[i][1] + 1 || mat[0].length : args[i] + 1;\r\n        if (!Array.isArray(prev)) {\r\n            result[prev].fill(value, first, last);\r\n        } else {\r\n            for (let ind = start; ind < end; ind++) {\r\n                result[ind].fill(value, first, last);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n/**\r\n * Operates on two matrices of the same size\r\n *\r\n * @param mat input matrix that initialized the function\r\n * @param operand second matrix with which operation is performed\r\n * @param operation function performing the desired operation\r\n * @returns result of the operation\r\n */\r\nfunction operate(mat, operand, operation) {\r\n    let result = [];\r\n    let op = operand();\r\n\r\n    for (let i = 0; i < mat.length; i++) {\r\n        let op1 = mat[i];\r\n        let op2 = op[i];\r\n        result.push(op1.map(function(elem, ind) {\r\n            return operation(elem, op2[ind]);\r\n        }));\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n\r\n/**\r\n * Finds the product of two matrices\r\n *\r\n * @param mat input matrix that initialized the function\r\n * @param operand second matrix with which operation is performed\r\n * @returns the product of the two matrices\r\n */\r\nfunction prod(mat, operand) {\r\n    let op1 = mat;\r\n    let op2 = operand();\r\n    let size1 = size(op1);\r\n    let size2 = size(op2);\r\n    let result = [];\r\n    if (size1[1] === size2[0]) {\r\n        for (let i = 0; i < size1[0]; i++) {\r\n            result[i] = [];\r\n            for (let j = 0; j < size2[1]; j++) {\r\n                for (let k = 0; k < size1[1]; k++) {\r\n                    if (result[i][j] === undefined) {\r\n                        result[i][j] = 0;\r\n                    }\r\n                    result[i][j] += multiplication(op1[i][k], op2[k][j]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n/**\r\n * Returns the transpose of a matrix, swaps rows with columns\r\n *\r\n * @param mat input matrix that initialized the function\r\n * @returns a matrix with rows and columns swapped from the original matrix\r\n */\r\nfunction trans(mat) {\r\n    let input = mat;\r\n    let s = size(mat);\r\n    let output = [];\r\n    for (let i = 0; i < s[0]; i++) {\r\n        for (let j = 0; j < s[1]; j++) {\r\n            if (Array.isArray(output[j])) {\r\n                output[j].push(input[i][j]);\r\n            } else {\r\n                output[j] = [input[i][j]];\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}\r\n\r\n/**\r\n * Private method to clone the matrix\r\n *\r\n * @param mat input matrix that initialized the function\r\n * @returns cloned matrix\r\n */\r\nfunction clone(mat) {\r\n    let result = [];\r\n    for (let i = 0; i < mat.length; i++) {\r\n        result.push(mat[i].slice(0));\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs addition\r\n *\r\n * @param op1 first operand\r\n * @param op2 second operand\r\n * @returns result\r\n */\r\nfunction addition(op1, op2) {\r\n    return op1 + op2;\r\n}\r\n\r\n/**\r\n * Performs subtraction\r\n *\r\n * @param op1 first operand\r\n * @param op2 second operand\r\n * @returns result\r\n */\r\nfunction subtraction(op1, op2) {\r\n    return op1 - op2;\r\n}\r\n\r\n/**\r\n * Performs multiplication\r\n *\r\n * @param op1 first operand\r\n * @param op2 second operand\r\n * @returns result\r\n */\r\nfunction multiplication(op1, op2) {\r\n    return op1 * op2;\r\n}\r\n\r\n/**\r\n * Performs division\r\n *\r\n * @param op1 first operand\r\n * @param op2 second operand\r\n * @returns result\r\n */\r\nfunction division(op1, op2) {\r\n    return op1/op2;\r\n}\r\n\r\n\r\n/**\r\n * Computes the determinant using row reduced echelon form\r\n * Works best if the elements are integers or rational numbers\r\n * The matrix must be a square\r\n *\r\n * @param mat input matrix that initialized the function\r\n * @returns determinant value as a number\r\n */\r\nfunction determinant(mat) {\r\n    let rationalized = rationalize(mat);\r\n    let siz = size(mat);\r\n    let det = rational(1);\r\n    let sign = 1;\r\n\r\n    for (let i = 0; i < siz[0] - 1; i++) {\r\n        for (let j = i + 1; j < siz[0]; j++) {\r\n            if (rationalized[j][i].num === 0) {\r\n                continue;\r\n            }\r\n            if (rationalized[i][i].num === 0) {\r\n                interchange(rationalized, i, j);\r\n                sign = -sign;\r\n                continue;\r\n            }\r\n            let temp = rationalized[j][i].div(rationalized[i][i]);\r\n            temp = rational(Math.abs(temp.num), temp.den);\r\n            if (Math.sign(rationalized[j][i].num) === Math.sign(rationalized[i][i].num)) {\r\n                temp = rational(-temp.num, temp.den);\r\n            }\r\n            for (let k = 0; k < siz[1]; k++) {\r\n                 rationalized[j][k] = temp.mul(rationalized[i][k]).add(rationalized[j][k]);\r\n            }\r\n        }\r\n    }\r\n\r\n    det = rationalized.reduce((prev, curr, index) => prev.mul(curr[index]), rational(1));\r\n\r\n    return sign * det.num/det.den;\r\n}\r\n\r\n/**\r\n * Interchanges one row index with another on passed matrix\r\n *\r\n * @param mat input matrix\r\n * @param ind1 one of the row indices to exchange\r\n * @param ind2 one of the row indices to exchange\r\n */\r\nfunction interchange(mat, ind1, ind2) {\r\n    let temp = mat[ind1];\r\n    mat[ind1] = mat[ind2];\r\n    mat[ind2] = temp;\r\n}\r\n\r\n/**\r\n * Inverts the input square matrix using row reduction technique\r\n * Works best if the elements are integers or rational numbers\r\n * The matrix has to be a square and non-singular\r\n *\r\n * @param mat input matrix\r\n * @returns inverse of the input matrix\r\n */\r\nfunction invert(mat) {\r\n    let rationalized = rationalize(mat);\r\n    let siz = size(mat);\r\n    let result = rationalize(generate(1).diag(siz[0]));\r\n\r\n    // row reduction\r\n    let i = 0;\r\n    let j = 0;\r\n    while (j < siz[0]) {\r\n        if (rationalized[i][j].num === 0) {\r\n            for (let k = i + 1; k < siz[0]; k++) {\r\n                if (rationalized[k][j].num !== 0) {\r\n                    interchange(rationalized, i, k);\r\n                    interchange(result, i, k);\r\n                }\r\n            }\r\n        }\r\n        if (rationalized[i][j].num !== 0) {\r\n            if (rationalized[i][j].num !== 1 || rationalized[i][j].den !== 1) {\r\n                let factor = rational(rationalized[i][j].num, rationalized[i][j].den);\r\n                for (let col = 0; col < siz[1]; col++) {\r\n                    rationalized[i][col] = rationalized[i][col].div(factor);\r\n                    result[i][col] = result[i][col].div(factor);\r\n                }\r\n            }\r\n            for (let k = i + 1; k < siz[0]; k++) {\r\n                let temp = rationalized[k][j];\r\n                for (let col = 0; col < siz[1]; col++) {\r\n                    rationalized[k][col] = rationalized[k][col].sub(temp.mul(rationalized[i][col]));\r\n                    result[k][col] = result[k][col].sub(temp.mul(result[i][col]));\r\n                }\r\n            }\r\n        }\r\n        i += 1;\r\n        j += 1;\r\n    }\r\n\r\n    // Further reduction to convert rationalized to identity\r\n    let last = siz[0] - 1;\r\n    if (rationalized[last][last].num !== 1 || rationalized[last][last].den !== 1) {\r\n        let factor = rational(rationalized[last][last].num, rationalized[last][last].den);\r\n        for (let col = 0; col < siz[1]; col++) {\r\n            rationalized[last][col] = rationalized[last][col].div(factor);\r\n            result[last][col] = result[last][col].div(factor);\r\n        }\r\n    }\r\n\r\n    for (let i = siz[0] - 1; i > 0; i--) {\r\n        for (let j = i - 1; j >= 0; j--) {\r\n            let temp = rational(-rationalized[j][i].num, rationalized[j][i].den);\r\n            for (let k = 0; k < siz[1]; k++) {\r\n                rationalized[j][k] = temp.mul(rationalized[i][k]).add(rationalized[j][k]);\r\n                result[j][k] = temp.mul(result[i][k]).add(result[j][k]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return derationalize(result);\r\n}\r\n\r\n/**\r\n * Applies a given function over the matrix, elementwise. Similar to Array.map()\r\n * The supplied function is provided 4 arguments:\r\n * the current element,\r\n * the row index,\r\n * the col index,\r\n * the matrix.\r\n *\r\n * @param mat input matrix\r\n * @returns matrix of same dimensions with values altered by the function.\r\n */\r\nfunction map(mat, func) {\r\n    const s = size(mat);\r\n    const result = [];\r\n    for (let i = 0; i < s[0]; i++) {\r\n        if(Array.isArray(mat[i])) {\r\n            result[i] = [];\r\n            for (let j = 0; j < s[1]; j++) {\r\n                result[i][j] = func(mat[i][j], [i, j], mat);\r\n            }\r\n        } else {\r\n            result[i] = func(mat[i], [i, 0], mat);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Converts a matrix of numbers to all rational type objects\r\n *\r\n * @param mat input matrix\r\n * @returns matrix with elements of type rational\r\n */\r\nfunction rationalize(mat) {\r\n    let rationalized = [];\r\n    mat.forEach((row, ind) => {\r\n        rationalized.push(row.map((ele) => rational(ele)));\r\n    });\r\n    return rationalized;\r\n}\r\n\r\n/**\r\n * Converts a rationalized matrix to all numerical values\r\n *\r\n * @param mat input matrix\r\n * @returns matrix with numerical values\r\n */\r\nfunction derationalize(mat) {\r\n    let derationalized = [];\r\n    mat.forEach((row, ind) => {\r\n        derationalized.push(row.map((ele) => ele.num/ele.den));\r\n    });\r\n    return derationalized;\r\n}\r\n\r\n/**\r\n * Checks the equality of two matrices\r\n * @param mat input matrix\r\n * @param operand second matrix\r\n */\r\nfunction equals(mat, operand) {\r\n    let op1 = mat;\r\n    let op2 = operand();\r\n    let size1 = size(op1);\r\n    let size2 = size(op2);\r\n\r\n    if (!size1.every((val, ind) => val === size2[ind])) {\r\n        return false;\r\n    }\r\n\r\n    return op1.every((val, ind1) => val.every((ele, ind2) => Math.abs(ele - op2[ind1][ind2]) < 1e-10));\r\n}   \r\n"],
  "mappings": "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",
  "names": ["i", "j"]
}
