import {
  mod,
  modBI
} from "./chunk-Y44FVENP.js";
import {
  __privateAdd,
  __privateGet
} from "./chunk-HPRLEMBT.js";

// node_modules/@gkucmierz/utils/src/SetCnt.mjs
var _map;
var SetCnt = class {
  constructor(iter) {
    __privateAdd(this, _map, /* @__PURE__ */ new Map());
    for (const el of iter ?? []) {
      this.add(el);
    }
  }
  add(el) {
    const cnt = this.cnt(el);
    __privateGet(this, _map).set(el, cnt + 1);
    return this;
  }
  has(el) {
    return __privateGet(this, _map).has(el);
  }
  delete(el) {
    if (!__privateGet(this, _map).has(el)) return false;
    const cnt = this.cnt(el);
    if (cnt === 1) return this.deleteAll(el);
    __privateGet(this, _map).set(el, cnt - 1);
    return true;
  }
  deleteAll(el) {
    __privateGet(this, _map).delete(el);
    return true;
  }
  cnt(el) {
    return __privateGet(this, _map).get(el) ?? 0;
  }
  *[Symbol.iterator]() {
    for (const el of __privateGet(this, _map)) {
      yield el;
    }
  }
  entries() {
    return this;
  }
  *values() {
    for (const [el, cnt] of __privateGet(this, _map)) {
      yield el;
    }
  }
  *keys() {
    for (const [el, cnt] of __privateGet(this, _map)) {
      yield cnt;
    }
  }
};
_map = new WeakMap();

// node_modules/@gkucmierz/utils/src/base64.mjs
var toBase64 = (string) => {
  const codeUnits = new Uint16Array(string.length);
  for (let i = 0; i < codeUnits.length; i++) {
    codeUnits[i] = string.charCodeAt(i);
  }
  return btoa(String.fromCharCode(...new Uint8Array(codeUnits.buffer)));
};
var fromBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return String.fromCharCode(...new Uint16Array(bytes.buffer));
};
var toUrl = {
  "+": "-",
  "/": "_"
};
var toBase64Url = (string) => {
  return toBase64(string).replace(/[\+\/]/g, (c) => toUrl[c]);
};
var fromUrl = {
  "-": "+",
  "_": "/"
};
var fromBase64Url = (encoded) => {
  return fromBase64(encoded.replace(/[\-\_]/g, (c) => fromUrl[c]));
};

// node_modules/@gkucmierz/utils/src/bijective-numeration.mjs
var num2bijective = (num, alpha = "12") => {
  const len = alpha.length;
  let c = 0;
  let x = 1;
  while (num >= x) {
    c++;
    num -= x;
    x *= len;
  }
  const res = [];
  for (let i = 0; i < c; i++) {
    const rem = num % len;
    res.unshift(alpha.charAt(num % len));
    num = (num - rem) / len;
  }
  return res.join("");
};
var bijective2num = (str, alpha = "12") => {
  const map = new Map([...alpha].map((c, i) => [c, i]));
  let res = 0;
  const len = alpha.length;
  return [...str].reduce((res2, c) => {
    return res2 * len + map.get(c) + 1;
  }, 0);
};
var num2bijectiveBI = (num, alpha = "12") => {
  const len = BigInt(alpha.length);
  let c = 0n;
  let x = 1n;
  while (num >= x) {
    c++;
    num -= x;
    x *= len;
  }
  const res = [];
  for (let i = 0n; i < c; i++) {
    const rem = num % len;
    res.unshift(alpha.charAt(Number(num % len)));
    num = (num - rem) / len;
  }
  return res.join("");
};
var bijective2numBI = (str, alpha = "12") => {
  const map = new Map([...alpha].map((c, i) => [c, BigInt(i)]));
  let res = 0n;
  const len = BigInt(alpha.length);
  return [...str].reduce((res2, c) => {
    return res2 * len + map.get(c) + 1n;
  }, 0n);
};

// node_modules/@gkucmierz/utils/src/binary-search.mjs
var binarySearchArr = (arr, target) => {
  let [a, b] = [0, arr.length];
  let lm;
  while (b - a > 0) {
    const mid = (a + b) / 2 | 0;
    const val = arr[mid];
    if (target < val) {
      b = mid;
    } else if (val < target) {
      a = mid;
    } else {
      return mid;
    }
    if (lm === mid) break;
    lm = mid;
  }
  return -1;
};
var binarySearchLE = (arr, target) => {
  let [a, b] = [0, arr.length];
  let lm;
  while (b - a > 0) {
    const mid = (a + b) / 2 | 0;
    const val = arr[mid];
    if (target < val) {
      b = mid;
    } else if (val <= target) {
      a = mid;
    }
    if (lm === mid) return mid;
    lm = mid;
  }
  return -1;
};
var binarySearchGE = (arr, target) => {
  let [a, b] = [0, arr.length];
  let lm;
  while (b - a > 0) {
    const mid = (a + b) / 2 | 0;
    const val = arr[mid];
    if (target > val) {
      a = mid;
    } else if (val >= target) {
      b = mid;
    }
    if (lm === mid) return mid + 1;
    lm = mid;
  }
  return 0;
};
var binarySearchRangeIncl = (arr, target) => {
  return [
    binarySearchGE(arr, target),
    binarySearchLE(arr, target)
  ];
};

// node_modules/@gkucmierz/utils/src/copy-case.mjs
var copyCase = (word, from) => {
  const isLower = (w) => w.toLowerCase() === w;
  const isUpper = (w) => w.toUpperCase() === w;
  if (isLower(from)) return word.toLowerCase();
  if (isUpper(from)) return word.toUpperCase();
  if (isUpper(from[0]) && isLower(from.slice(1))) {
    return word[0].toUpperCase() + word.slice(1).toLowerCase();
  }
  return word;
};

// node_modules/@gkucmierz/utils/src/egcd.mjs
var egcd = (a, b) => {
  let [x, y] = [0, 1];
  let [u, v] = [1, 0];
  while (a !== 0) {
    const [q, r] = [b / a | 0, b % a];
    const [m, n] = [x - u * q, y - v * q];
    [b, a, x, y, u, v] = [a, r, u, v, m, n];
  }
  return [b, x, y];
};

// node_modules/@gkucmierz/utils/src/factors.mjs
var factors = (n) => {
  if (n < 2) return [];
  const res = [];
  let max = Math.floor(Math.sqrt(n));
  for (let i = 2; i <= max; ++i) {
    if (n % i === 0) {
      res.push(i);
      n /= i;
      max = Math.floor(Math.sqrt(n));
      i = (Math.min(...res) || 2) - 1;
    }
  }
  res.push(n);
  return res;
};
var factorsBI = (n) => {
  if (n < 2n) return [];
  const res = [];
  for (let i = 2n; i * i <= n; ++i) {
    if (n % i === 0n) {
      res.push(i);
      n /= i;
      i = 1n;
    }
  }
  res.push(n);
  return res;
};

// node_modules/@gkucmierz/utils/src/gcd.mjs
var getGCD = (ZERO) => {
  return (a, b) => {
    if (a < ZERO) a = -a;
    if (b < ZERO) b = -b;
    if (b > a) {
      [a, b] = [b, a];
    }
    while (true) {
      if (b === ZERO) return a;
      a %= b;
      if (a === ZERO) return b;
      b %= a;
    }
  };
};
var gcd = getGCD(0);
var gcdBI = getGCD(0n);

// node_modules/@gkucmierz/utils/src/get-type.mjs
var getType = (val) => {
  const str = Object.prototype.toString.call(val);
  return str.slice(8, -1).toLowerCase();
};

// node_modules/@gkucmierz/utils/src/gpn.mjs
var getGpn = (zero, one, two, three) => {
  const gk = (k) => k * (three * k - one) / two;
  return (n) => {
    const m = (n + one) / two | zero;
    return n % two === zero ? gk(-m) : gk(m);
  };
};
var gpn = getGpn(0, 1, 2, 3);
var gpnBI = getGpn(0n, 1n, 2n, 3n);

// node_modules/@gkucmierz/utils/src/heap.mjs
var Heap = (valFn = (n) => n) => {
  const arr = [-1];
  const up = (idx) => {
    while (idx > 1) {
      const ni = idx / 2 | 0;
      if (valFn(arr[idx]) < valFn(arr[ni])) {
        [arr[idx], arr[ni]] = [arr[ni], arr[idx]];
      }
      idx = ni;
    }
    return idx;
  };
  return {
    add: (el) => up(arr.push(el) - 1),
    take: () => {
      const len = arr.length;
      if (len <= 1) return [][0];
      let idx = 1;
      const res = arr[idx];
      while (idx < len) {
        const ia = idx * 2;
        const ib = idx * 2 + 1;
        if (ia >= len) break;
        if (ib >= len || valFn(arr[ia]) < valFn(arr[ib])) {
          arr[idx] = arr[ia];
          idx = ia;
        } else {
          arr[idx] = arr[ib];
          idx = ib;
        }
      }
      if (idx === arr.length - 1) {
        arr.pop();
      } else {
        arr[idx] = arr.pop();
        up(idx);
      }
      return res;
    },
    size: () => arr.length - 1,
    data: () => arr.slice(1)
  };
};

// node_modules/@gkucmierz/utils/src/square-root.mjs
var squareRoot = (n) => n ** 0.5;
var squareRootBI = (n) => {
  if (n === 0n) return 0n;
  if (n < 4n) return 1n;
  if (n < 9n) return 2n;
  if (n < 16n) return 3n;
  let res = BigInt(n.toString().substr(0, n.toString().length / 2));
  let last;
  while (true) {
    last = res;
    res = (res + n / res) / 2n;
    const p = res * res;
    if (p === n) return res;
    if (last === res) return res;
    const next = p + res * 2n - 1n;
    if (n > next) return res;
  }
  return res;
};

// node_modules/@gkucmierz/utils/src/herons-formula.mjs
var getHeronsFormula = (four, sq) => (a, b, c) => {
  return sq((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c)) / four;
};
var heronsFormula = getHeronsFormula(4, (n) => n ** 0.5);
var heronsFormulaBI = getHeronsFormula(4n, squareRootBI);

// node_modules/@gkucmierz/utils/src/lcm.mjs
var getLcm = (gcd2) => {
  return (a, b) => a * b / gcd2(a, b);
};
var lcm = getLcm(gcd);
var lcmBI = getLcm(gcdBI);

// node_modules/@gkucmierz/utils/src/list-node.mjs
var ListNode = class _ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
  toArr() {
    const ret = [];
    let node = this;
    const set = /* @__PURE__ */ new Set();
    while (node) {
      if (set.has(node)) throw Error("Cyclic reference detected");
      set.add(node);
      ret.push(node.val);
      node = node.next;
    }
    return ret;
  }
  static fromArr(iter) {
    const head = new _ListNode();
    let node = head;
    for (let val of iter) {
      node.next = new _ListNode(val);
      node = node.next;
    }
    return head.next;
  }
};

// node_modules/@gkucmierz/utils/src/matrix.mjs
var matrixAsArray = (matrix) => {
  const [h, w] = [matrix.length, matrix[0].length];
  return new Proxy([], {
    get(target, prop, receiver) {
      if (prop === "length") return h * w;
      const idx = +prop;
      const col = idx % w;
      const row = (idx - col) / w;
      return matrix[row][col];
    }
  });
};

// node_modules/@gkucmierz/utils/src/memoize.mjs
var memoize = (fn) => {
  const maps = [];
  const getLeafMap = (args) => {
    if (!maps[args.length]) maps[args.length] = /* @__PURE__ */ new Map();
    const map = maps[args.length];
    const leaf = args.reduce((map2, arg) => {
      if (map2.has(arg)) return map2.get(arg);
      const tmp = /* @__PURE__ */ new Map();
      map2.set(arg, tmp);
      return tmp;
    }, map);
    return leaf;
  };
  const zero = {
    called: false,
    ret: null
  };
  return function() {
    const args = [...arguments];
    if (args.length === 0) {
      if (zero.called) return zero.ret;
      zero.called = true;
      return zero.ret = fn();
    }
    const [firstArg, ...restArgs] = args;
    const map = getLeafMap(restArgs);
    if (map.has(firstArg)) return map.get(firstArg);
    const ret = fn(...args);
    map.set(firstArg, ret);
    return ret;
  };
};

// node_modules/@gkucmierz/utils/src/phi.mjs
var getPhiEuler = (factors2) => {
  return (n) => {
    return [...new Set(factors2(n))].reduce((res, f) => res - res / f, n);
  };
};
var phi = getPhiEuler(factors);
var phiBI = getPhiEuler(factorsBI);

// node_modules/@gkucmierz/utils/src/pow-mod.mjs
var getPowMod = (ZERO, ONE, TWO, floor) => {
  return (base, exponent, modulus = null) => {
    if (modulus === null) return base ** exponent;
    if (modulus === ONE) return ZERO;
    let result = ONE;
    base = base % modulus;
    while (exponent > ZERO) {
      if (exponent % TWO === ONE) {
        result = result * base % modulus;
      }
      exponent = floor(exponent / TWO);
      base = base * base % modulus;
    }
    return result;
  };
};
var powMod = getPowMod(0, 1, 2, (n) => Math.floor(n));
var powModBI = getPowMod(0n, 1n, 2n, (n) => n);

// node_modules/@gkucmierz/utils/src/range-array.mjs
var range2array = (ranges) => {
  return ranges.reduce((arr, range) => {
    const min = range[0];
    const max = range[1] ?? min;
    return arr.push(
      ...new Array(max - min + 1).fill(0).map((n, i) => min + i)
    ), arr;
  }, []);
};
var array2range = (arr) => {
  const ranges = [];
  let last = arr[0];
  let begin = last;
  for (let i = 1; i <= arr.length; ++i) {
    const n = arr[i];
    if (n !== last + 1) {
      ranges.push([begin, last]);
      begin = n;
    }
    last = n;
  }
  return ranges;
};

// node_modules/@gkucmierz/utils/src/tonelli-shanks.mjs
var tonelliShanksBI = (n, p) => {
  let s = 0n;
  let q = p - 1n;
  while ((q & 1n) === 0n) {
    q /= 2n;
    ++s;
  }
  if (s === 1n) {
    const r2 = powModBI(n, (p + 1n) / 4n, p);
    if (r2 * r2 % p === n) return r2;
    return 0n;
  }
  let z = 1n;
  while (powModBI(++z, (p - 1n) / 2n, p) !== p - 1n) ;
  let c = powModBI(z, q, p);
  let r = powModBI(n, (q + 1n) / 2n, p);
  let t = powModBI(n, q, p);
  let m = s;
  while (t !== 1n) {
    let tt = t;
    let i = 0n;
    while (tt !== 1n) {
      tt = tt * tt % p;
      ++i;
      if (i === m) return 0n;
    }
    let b = powModBI(c, powModBI(2n, m - i - 1n, p - 1n), p);
    let b2 = b * b % p;
    r = r * b % p;
    t = t * b2 % p;
    c = b2;
    m = i;
  }
  if (r * r % p === n) return r;
  return 0n;
};

// node_modules/@gkucmierz/utils/main.mjs
var main_default = [
  SetCnt,
  fromBase64,
  fromBase64Url,
  toBase64,
  toBase64Url,
  bijective2num,
  bijective2numBI,
  num2bijective,
  num2bijectiveBI,
  binarySearchArr,
  copyCase,
  egcd,
  factors,
  factorsBI,
  gcd,
  gcdBI,
  getType,
  gpn,
  gpnBI,
  Heap,
  heronsFormula,
  heronsFormulaBI,
  lcm,
  lcmBI,
  ListNode,
  matrixAsArray,
  memoize,
  mod,
  modBI,
  phi,
  phiBI,
  powMod,
  powModBI,
  array2range,
  range2array,
  squareRoot,
  squareRootBI,
  tonelliShanksBI
];
export {
  Heap,
  ListNode,
  SetCnt,
  array2range,
  bijective2num,
  bijective2numBI,
  binarySearchArr,
  binarySearchGE,
  binarySearchLE,
  binarySearchRangeIncl,
  copyCase,
  main_default as default,
  egcd,
  factors,
  factorsBI,
  fromBase64,
  fromBase64Url,
  gcd,
  gcdBI,
  getType,
  gpn,
  gpnBI,
  heronsFormula,
  heronsFormulaBI,
  lcm,
  lcmBI,
  matrixAsArray,
  memoize,
  mod,
  modBI,
  num2bijective,
  num2bijectiveBI,
  phi,
  phiBI,
  powMod,
  powModBI,
  range2array,
  squareRoot,
  squareRootBI,
  toBase64,
  toBase64Url,
  tonelliShanksBI
};
//# sourceMappingURL=@gkucmierz_utils.js.map
